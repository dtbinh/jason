% To generate Jason 's FAQ.html

\documentclass{article}

\usepackage{tabularx}
\usepackage{html}
\usepackage{hthtml}
\usepackage{xspace}

\newcommand{\jason}[0]{\htlink{\textit{Jason}}{http://jason.sf.net}\xspace}
\newcommand{\saci}[0]{\htlink{\textsc{Saci}}{http://www.lti.pcs.usp.br/saci}\xspace}
\newcommand{\jade}[0]{\htlink{\textsc{Jade}}{http://jade.tilab.com/}\xspace}
\newcommand{\code}[1]{\texttt{#1}}

\begin{document}



\html{\begin{rawhtml}<h0><b><i>Jason</i></b> FAQ
      <br><font size="-1">(for version 1.1)</font></h0>
      \end{rawhtml}}
\latex{\begin{center}{\Huge\jason FAQ}\end{center}}

\tableofcontents


% ---------------------------------------------------------------------
\section{Platform Name}

\subsection{Why is the platform called "Jason"?}

Jason initially stood for `\textbf{J}ava-based \textbf{A}gentSpeak interpreter
used with \textbf{S}ACI for multi-agent distribution \textbf{o}ver the
\textbf{n}et'. Since it not based only on SACI anymore (other infrastructures
are available) and the acronyms was quite `forced', we decided the use Jason
as a proper name for the interpreter.

We are also somehow inspired by the \jason as a hero in Greek mythology. Click
\begin{rawhtml}
  <a
  href="http://www.perseus.tufts.edu/cgi-bin/ptext?doc=Perseus%3Atext%3A1999.04.0004%3Ahead%3D%234815">here</a>
\end{rawhtml}
for an entry on "Jason" in the Perseus Encyclopaedia (Perseus is an
excellent source of Classics, maintained by Tufts University).


% ---------------------------------------------------------------------
\section{Internal Actions}

\subsection{How to create a new internal actions?}

The following steps will help you to define your internal action
(IA). The steps 1-4,6 are automatically done by Jason IDE, see menu
Plugin->Jason->New internal action".

\begin{enumerate}
\item In your MAS project directory, create a sub-directory called
  \code{myLib} (user's internal actions must be placed in a Java
  package, which provides a library of actions). In case this package
  directory is under your project directory, \jason automatically sets
  the classpath.

\item Copy an existing \jason internal action
  (\code{Jason/src/stdlib/concat.java}, for instance) to the
  \code{myLib} directory. This file will be used as a skeleton for
  your new IA.

\item Rename the file \code{myLib/concat.java} to
  \code{myLib/myIA.java}.

\item Edit this file and change the \code{package} name to
  \code{myLib}, and the class name to \code{myIA}.

  The code will likely look like
\begin{verbatim}
package myLib;

import jason.asSemantics.*;
import jason.asSyntax.*;

public class myIA extends DefaultInternalAction {
   public Object execute(TransitionSystem ts, 
                         Unifier un, 
                         Term[] args) 
                 throws Exception {
      ....
   }
}
\end{verbatim}

\item Code the \code{execute} method in order to implement the
  internal action.

\item Compile the new class
\begin{verbatim}
cd <your project directory>
javac -classpath ...../Jason/lib/jason.jar:. myLib/myIA.java
\end{verbatim}

\item Use the new IA in AgentSpeak sources, for example:
\begin{verbatim}
+a(X) : true
   <- ... ;
      myLib.myIA(A,B);
      ... .
\end{verbatim}


\end{enumerate}

\section{Environment}

\subsection{Is it possible to call an internal action from the
environment?}

Most of the internal actions (IAs) are developed from an agent
perspective, since they are conceived to be called by agents. Thus the
\code{execute} method needs an agent's
\code{TransitionSystem} (TS) to be executed (e.g. \code{.myName} make
sense only when called by an agent).

%However, some internal actions can be executed without a reference for
%a TS. For example, the IA \code{.killAgent} can
%be executed from the environment as shown in the code below:
%\begin{verbatim}
%import jason.stdlib.killAgent;
%...
%... in a centralised infrastructure ....
%...
%new killAgent().killCentralisedAg("bob", getEnvironmentInfraTier());
%...
%\end{verbatim}

\subsection{How to discover the name of the agents in the environment initialisation?}

Once the environment is created before the agents, the set of agents
is empty when the environment is created and thus the method
\texttt{getEnvironmentInfraTier().getRuntimeServices().getAgentsName()}
can not be used. However, if the set of agents is defined only by the
.mas2j project file (i.e., no agent is dynamically created), the name
of the agents can be obtained from that file.

For instance, a project file called \texttt{ag-names.mas2j} can be
passed as parameter to the environment as in the following example:

\begin{verbatim}
MAS ag_names {
     environment: TestEnv("ag-names.mas2j")
     agents:   a #10;   b;
}
\end{verbatim}

The following code (in the environment initialisation) can then get
all the names:

\begin{verbatim}
public void init(String[] args) {
   // args[0] is the name of the project file
   try {
      // parse that file
      jason.mas2j.parser.mas2j parser =
          new jason.mas2j.parser.mas2j(new FileInputStream(args[0]));
      MAS2JProject project = parser.mas();
			
      List<String> names = new ArrayList<String>();
      // get the names from the project
      for (AgentParameters ap : project.getAgents()) {
         String agName = ap.name;
         for (int cAg = 0; cAg < ap.qty; cAg++) {
            String numberedAg = agName;
            if (ap.qty > 1) {
               numberedAg += (cAg + 1);
            }
         names.add(numberedAg);
      }
   }
   logger.info("Agents' name: "+names);
   ...
\end{verbatim}



% ---------------------------------------------------------------------
\section{MAS Execution}

\subsection{How to delay the MAS execution?}

If you have an environment class, the easiest way is simply add a
sleep in the \code{executeAction} method. For example:
\begin{verbatim}
    ...
    public boolean executeAction(String agent, Term action) {
        ...
        try { 
          Thread.sleep(500); 
        } catch (Exception e) {}
        ...
    }
\end{verbatim}

In case the agents do not act or there is no environment class, you
should write a controller class (see \ref{sec:controlclass}). 

For instance, the controller class could be:
\begin{verbatim}
package myPkg;
import ...
public class MyExecutionControl extends ExecutionControl {
    protected void allAgsFinished() {
        try { 
          Thread.sleep(500); 
        } catch (Exception e) {}
    }
}
\end{verbatim}

To use this controller, the project file must be
\begin{verbatim}
MAS test {
    ...
    executionControl: myPkg.MyExecutionControl

    agents:  ...
}
\end{verbatim}

\subsection{Is it possible to add/remove an agent into a running MAS?}

The internal action \code{.create_agent} can be used to dynamically
add a new agent into the running MAS. For example, when the plan:
\begin{verbatim}
+a : true 
   <- ... ; 
      .create_agent(bob, "myAgent.asl");
      ... .
\end{verbatim}
is executed, it will create a new agent called "bob" based on the
AgentSpeak code available at file "myAgent.asl".

Analogously, the internal action \code{.killAgent(<agent name>)}
removes the agent identified by \code{<agent name>} from the current
MAS. The createAgDemo project that comes with Jason distribution files
has examples of using these features.

New agents can also be created in the user Java code, for example:

\begin{verbatim}
public class myEnv extends Environment {
  ...
  public boolean executeAction(String ag, Term action) {
    ...
    getEnvironmentInfraTier().getRuntimeServices().
     .createAgent(
         "anotherAg",     // agent name
         "ag1.asl",       // AgentSpeak source
         null,            // default agent class
         null,            // default architecture class
         null,            // default belief base parameters
         null);           // default settings
  }
}
\end{verbatim}
The RuntimeServices interface, used in the code above, provides useful
services transparently from the underlying infrastructure
(Centralised, Saci, ...). The interface's methods include agent
creation, agent killing, and stop the system (see the API
documentation for more information).

Note that if you're using the \saci infrastructure, new
agents (possibly not \jason agents, see \ref{sec:whysaci}) can
enter the MAS using \saci features for open MAS.

\subsection{How to log the execution?}

\jason uses the \htlink{Java logging
  API}{http://java.sun.com/j2se/1.5.0/docs/guide/logging/overview.html}
% \htlink{Log4J}{http://logging.apache.org/log4j/}
to output messages into the console (the default console is called
MASConsole). To change the log level or device, select the menu
``Plugins -> Jason -> Edit Log properties''. The default configuration
file has comments that helps you to customise your log. For instance,
to output messages both into an XML file and in the console, you only
need to set the log handler as in the following line:
\begin{verbatim}
handlers = java.util.logging.FileHandler, java.util.logging.ConsoleHandler
\end{verbatim}
To get only console output (without MASConsole GUI):
\begin{verbatim}
handlers = java.util.logging.ConsoleHandler
\end{verbatim}

\subsection{How to set the classpath for running a system?}

There are three ways to set the classpath of a project:
\begin{enumerate}
\item Create a lib directory in the project and include the jar files
  there. The ant script created by \jason to run the project
  (bin/build.xml) includes lib/*.jar in the classpath. This approach
  is used in the examples/gold-miners.

\item In case you do not want to copy files into the project, the
  \texttt{classpath} entry in the .mas2j file can be used:
\begin{verbatim}
MAS masid {
   agents: .......
   classpath: "../../jdom.jar"; 
              "../../otherproject/classes";
              "/apache/**/*.jar; // all jar files below /apache
}
\end{verbatim}
  Several items can be added as strings separated by ";". This
  approach is used in the examples/sniffer.

\item If a more customised startup is required for your system, create
  a file named bin/c-build.xml with the template below:

\begin{verbatim}
<project name ="mybuild" basedir="..">
    <import file="build.xml"/>
	
    <target name="user-init">
        <!-- add here all your custom initialisation -->
    </target>
	
    <target name="user-end">
        <!-- add here all your custom termination -->
    </target>

    <!-- you can also "override" other tasks from build.xml -->
</project>
\end{verbatim}
  If a c-build.xml file exists, it is used to run your application
  instead of build.xml.
\end{enumerate}

\subsection{Which execution modes are available?}

\jason is distributed with three execution modes:
\begin{itemize}
\item \textbf{Asynchronous}: all agents run asynchronously. An agent goes to
  its next reasoning cycle as soon as it has finished its current cycle.  This
  is the \textit{default} execution mode.
  
\item \textbf{Synchronous}: all agents perform one reasoning cycle at every
  "global execution step".  When an agent finished its reasoning cycle, it
  informs \jason's controller and waits for a "carry on" signal.  The \jason
  controller waits until all agents have finished their reasoning cycles and
  then sends the "carry on" signal to them.

To use this execution mode, you have to set up a controller class in
the .mas2j configuration, for example:
\begin{verbatim}
MAS test {
    infrastructure: Centralised
    environment: testEnv

    executionControl: jason.control.ExecutionControl

    agents:  ...
}
\end{verbatim}

The \code{jason.control.ExecutionControl} class implements exactly the "Jason
controller" described above.


\item \textbf{Debug}: this execution mode is similar to the synchronous mode,
  except that the \jason controller will also wait until the user clicks on a
  ``Step'' button before sending the ``carry on'' signal to the agents.
  
  To use this execution mode you can just press the ``debug'' button rather
  than the ``run'' button of the GUI, or you can to set up a debug controller
  class in the .mas2j configuration, for example:
\begin{verbatim}
MAS test {
    infrastructure: Centralised
    environment: testEnv

    executionControl: jason.control.ExecutionControlGUI

    agents:  ...
}
\end{verbatim}
  
  The \code{jason.control.ExecutionControlGUI} class implements the "Jason
  controller" with a GUI for debugging. This graphical tool is called
  "\jason's Mind Inspector", as it allows users to observe all changes in
  agents' mental attitudes after a reasoning cycle. This also applies to
  distributed agents (using \saci).

\end{itemize}



\subsection{How can I control agents' execution?}\label{sec:controlclass}

If you have other specific needs for controlling agents' execution, you have
to implement an \code{ExecutionControl} sub-class and specify it in the .mas2j
file.

You will most likely have to override the following methods:

\begin{verbatim}
public void receiveFinishedCycle(String agName, boolean breakpoint) {
   super.receiveFinishedCycle(agName, breakpoint);
   ... your code ...
}
protected void allAgsFinished() {
   ... your code ...
}
\end{verbatim}

These methods are called by \jason when one agent has finished its reasoning
cycle and when all agents have finished the current "global execution step".

To signal the agents to "carry on", your class can use the following code:
\begin{verbatim}
   fJasonControl.informAllAgsToPerformCycle();
\end{verbatim}

You should have a look at the \code{ExecutionControlGUI} class for an example
of how to do this, and the API documentation for further available methods
inherited from \code{ExecutionControl}.

% ---------------------------------------------------------------------
\section{\jason Infrastructures}


\subsection{What are infrastructures for?}

An infrastructure provides the following services for the MAS:
\begin{itemize}
\item communication (e.g., the \saci infrastructure implements
  communication based on
  KQML whilst \jade implements it using FIPA-ACL),
\item control of the agent life cycle (creation, running, destruction).
\end{itemize}

\subsection{Which infrastructures are available?}

The current version of \jason has the following infrastructures:
\begin{description}
\item[Centralised:] this infrastructure runs all agents in the
  same host. It provides fast startup and high performance for systems
  that can be executed in a single computer. It is also useful to test
  and develop (prototype) systems. Centralised is the default infrastructure.

\item[Saci:] provides distribution and communication based on KQML;
  click 
\begin{rawhtml}
  <a href="http://www.lti.pcs.usp.br/saci">here</a>
\end{rawhtml}
  for more details.

\item[Jade:] provides distribution and communication using 
\begin{rawhtml}
  <a href="http://jade.tilab.com/">Jade</a>,
\end{rawhtml}
  which is based on
  FIPA-ACL. With this infrastructure, all tools available with \jade
  (e.g., Sniffer and Inspector) are also available to monitor and
  inspect \jason agents.

  Since \jason agents use KQML and \jade uses FIPA-ACL, we opted
  to translate the messages from KQML to FIPA-ACL and vice-versa to
  maintain the AgentSpeak programming the same for all
  infrastructures. The following table summarises the translation of the
  basic performatives:
  \begin{center}
    \begin{tabular}{ll}
      \hline
      FIPA-ACL & KQML \\
      \hline
      inform & tell \\
      query-ref & askOne \\
      request & achieve \\
      \hline
    \end{tabular}
  \end{center}

  You find more information about this infrastructure in the
  \htlink{the Jason-JADE mini-tutorial}{http://jason.sourceforge.net/mini-tutorial/jason-jade/index.html}.
\end{itemize}

\subsection{How to select an infrastructure?}

In the \texttt{.mas2j} project file, use the `\emph{infrastructure}'
entry to select one infrastructure, for example to use Centralised:
\begin{verbatim}
MAS auction {
    infrastructure: Centralised
    agents: ag1; ag2; ag3; 
}
\end{verbatim}
to use Saci:
\begin{verbatim}
MAS auction {
    infrastructure: Saci
    agents: ag1; ag2; ag3; 
}
\end{verbatim}
and to use Jade:
\begin{verbatim}
MAS auction {
    infrastructure: Jade
    agents: ag1; ag2; ag3; 
}
\end{verbatim}

Note that the agents do not need to be changed for different
infrastructures. The \jason Agent Architecture binds them to the
available infrastructure.

\subsection{When should I use the \saci or \jade infrastructures?}\label{sec:whysaci}

The centralised infrastructure does not support:
\begin{itemize}
\item execution of the agents at distributed hosts, and
\item interoperability with non-\jason agents.
\end{itemize}

If you need any of these features, you should choose the \saci or
\jade infrastructures (or implement/plug a new infrastructure for/into
\jason yourself).  The interoperability with non-\jason agents is
achieved by \saci through KQML communication. An example of
communication between \jason and \saci agents (implemented in Java) is
available at \htlink{Source
  Force}{https://sourceforge.net/project/showfiles.php?group_id=98417}.

\subsection{How to customise the \jade container?}

All parameters normally used to start a \jade container can be set in
the menu Plugins -> Plugins Options -> Jason -> jade.Boot
arguments. For instance, to start a non-main container when running
the project, the following arguments can be used (supposing the main
container is running at x.com):
\begin{verbatim}
-gui -container -host x.com
\end{verbatim}

\subsection{How to start a \jason agent with \texttt{jade.Boot}?}

The \jade agent wrapper should be used to start a \jason agent using
\texttt{jade.Boot}, rather than doing it from the \jason IDE. For
example, to start a \jason agent called `bob' based on the
AgentSpeak source of the file \texttt{auctioneer.asl}, run the
following command in a shell:
\begin{verbatim}
java jade.Boot bob:jason.infra.jade.JadeAgArch(auctionner.asl)
\end{verbatim}

To start up also a simulated environment
(implemented, for instance, in the \texttt{Env} class):

\begin{verbatim}
java jade.Boot \
 environment:jason.infra.jade.JadeEnvironment(Env) \
 bob:jason.infra.jade.JadeAgArch(auctionner.asl)
\end{verbatim}


\subsection{Is it possible to use only the \jason BDI engine?}

If you want to use only the \jason AgentSpeak interpreter and reasoning
features, you can implement your own agent class where the \jason available
infrastructures are not used.  This class must function as an "overall agent
architecture" for the AgentSpeak interpreter, i.e., it has to send
percepts to the interpreter and get the agent actions (which result from
the AgentSpeak "reasoning").

Suppose you need a simple agent that interprets and reasons according to the
following AgentSpeak source:
\begin{verbatim}
+x(N) : N < 3  <- do(0).

+x(N) : N >= 3 <- do(50).
\end{verbatim}

The following class implements the required architecture (the complete
code is available with the examples in the \jason distribution).  This
code simply adds \code{x(10)} into the agent's belief base through
perception and get the output action, in this case \code{do(50)}.

\begin{verbatim}
public class SimpleJasonAgent extends AgArch {
    public static void main(String[] a) {
       ...
       SimpleJasonAgent ag = new SimpleJasonAgent();
       ag.run();
    }

    public SimpleJasonAgent() {
         // set up the Jason agent and the 
         // TransitionSystem (the BDI Engine where the AS 
         // Semantics is implemented).

         Agent ag = new Agent();
         setTS(ag.initAg(this, 
                         new DefaultBeliefBase(), 
                         "demo.asl", // source code
                         new Settings()));
    }
    
    public String getAgName() {
        return "Bob";
    }

    public void run() {
        while (true) {
          // calls the Jason engine to perform one reasoning cycle
          getTS().reasoningCycle();
        }
    }

    // this method just add some perception for the agent
    public List<Literal> perceive() {
        List<Literal> l = new ArrayList<Literal>();
        l.add(Literal.parseLiteral("x(10)"));
        return l;
    }

    // this method get the agent actions
    public void act(ActionExec action, List<ActionExec> feedback) {
        getTS().getLogger().info("Agent " + getAgName() + 
                             " is doing: " + action.getActionTerm());
        // set that the execution was ok
        action.setResult(true);
        feedback.add(action);
    }
}
\end{verbatim}

To run this agent:
\begin{verbatim}
export CLASSPATH= ../../lib/jason.jar:.
javac SimpleJasonAgent.java
java  SimpleJasonAgent
\end{verbatim}

The output will be 
\begin{verbatim}
[Bob] Agent Bob is doing: do(50)
\end{verbatim}

Of course, the AgentSpeak code in this example cannot use communicative
actions, since the specific architecture given above does not implement
communication.

\section{AgentSpeak Language}

Thanks to Mehdi Dastani for these questions.

\subsection{What exactly are the cases where negative events of the forms
  "-!p" and "-?p" are generated?}

A test goal "?p" in the body of a plan first checks the belief base,
and if it fails, it still tries to generate an internal event as that
might have been a more sophisticated query for which the programmer
created a whole plan with "+?p" as triggering event, then that could
be executed. Events "-!p" and "-?p" are only generated if an executing
plan for "+!g" and "+?g" (respectively) fail. Here's what the chapter
and the manual says about this:

\begin{quote}
  Events for handling plan failure are already available in Jason,
  although they are not formalised in the semantics yet. If an action
  fails or there is no applicable plan for a subgoal in the plan being
  executed to handle an internal event with a goal addition "+!g",
  then the whole failed plan is removed from the top of the intention
  and an internal event for "-!g" associated with that same intention
  is generated. If the programmer provided a plan that has a
  triggering event matching "-!g" and is applicable, such plan will be
  pushed on top of the intention, so the programmer can specify in the
  body of such plan how that particular failure is to be handled. If
  no such plan is available, the whole intention is discarded and a
  warning is printed out to the console. Effectively, this provides a
  means for programmers to "clean up" after a failed plan and before
  "backtracking" (that is, to make up for actions that had already
  been executed but left things in an inappropriate state for next
  attempts to achieve the goal). For example, for an agent that
  persist on a goal "!g" for as long as there are applicable plans for
  "+!g", suffices it to include a plan "-g! : true <- true." in the
  plan library. Note that the body can be empty as a goal is only
  removed from the body of a plan when the intended means chosen for
  that goal finishes successfully. It is also simple to specify a plan
  which, under specific condition, chooses to drop the intention
  altogether (by means of a standard internal action mentioned below).
\end{quote}

\subsection{Does "+p" (or "-p") in a plan body cause two effects,
  i.e. updating the belief base and generating the events "+p" (or "-p")?}

Yes, it causes both effects. Note, importantly, that one of the interpreter
configuration options allow the user to choose whether the event (\textbf{if}
it is by chance relevant to any plans the agent has) will be treated as
internal (pushed on top of the intention) or external (a new focus of
attention is created).

\subsection{Does "?p" in a plan body cause two effects, i.e. testing p
from the belief base and generating the events "+?p"? Is "-?p"
  generated when a test goal "?p" is failed? When does the test goal
  "?p" fails?}

When "?p" is executed, first the interpreter tries a simple query to the
belief base. If that doesn't succeed, before failing the intention, first an
internal event for "+?g" is generated, if that has no applicable plans, then
the plan fails (fails "normally", i.e., for the "no applicable plans"
reason) --- there could be still a "-?g" plan to be tried; if there's none,
the intention is discarded and a message printed to the console to let the
user know.

\subsection{It is claimed that open-world assumption is available. What
does this mean? Do we have a three-valued logic?}

No, we don't use three-valued logic. It means there is "strong negation", the
operator is "\url{~}". When assuming open world, the user models the
environment with a set of propositions known to be explicitly true and a set
of propositions known to be explicitly false of the environment at a certain
moment in time (the latter are literals preceeded by the \url{~} operator).
Of course, there is still default negation (as usual logic programming
languages), so you can say, in the context of a plan, "not p(t) \& not
\url{~}p(t)" to check if the agent is uncertain about "p(t)". Note that it's
completely up to the user to prevent paraconsistency (or to use it, if s/he
wants). You could add internal beliefs (or have beliefs from perception of the
environment) that p(t) is true and that ~p(t) is also true: \jason won't do
consistency checks for you! Note that strong negation can also appear in the
triggering events, plan body, anywhere a literal can appear.


\subsection{What's the difference between ! and !!?}

The difference between ! and !! is that the latter causes the goal to
be pursued as a separate intention. Within the body of a plan in one
intention, if you have "!g1; !g2" the agent will attempt to achieve g2
only after achieving (or finishing executing a plan for) g1.  If you
say "!!g1; !g2" the agent will then have another separate intention to
achieve g1 and can immediately start attempting to achieve g2. What
will be done first (executing a bit of the intention with g1 or the
old intention with g2) will depend on the choices that the intention
selection function makes. 

You may have noticed !! is used a lot at the end of recursive
plans as in the following code:
\begin{verbatim}
+!g : end_recursion_context.
+!g : true <- action1; !!g.
\end{verbatim}
In this case, the !! is used to avoid Jason creating long stacks of
plans. 


\subsection{Why is \jason's plan failure mechanism different from
  other agent platforms?}

Some other platforms handle plan failure in the following way. When a
plan is selected as an intended means to achieve a goal (more
generally, to handle an event), other applicable plans might be
available or indeed other instantiations of the plan's variables (to
make the context a logical consequence of the belief base) might be
possible. Those platforms then make a "note" of all those plans and
plan instantiations. If the plan currently being executed fails,
another plan is chosen from that set of plans initially recorded as
alternative plans for handling that event. This has the great
advantage that the platform does not have to check for applicable
plans again, and has as disadvantage the fact that possibly the
agent's beliefs have changed and so plan considered applicable at the
time the first plan was selected, are actually no longer applicable
(yet they will be attempted, which increases the chance of the chosen
alternative plan failing as well).

In \jason, we opted for a different approach. When a plan with a
triggering event "\texttt{+!g}" fails, we generate an event
"\texttt{-!g}" and if the programmer provided a plan for that event
that is currently applicable, that plan is pushed on top of the
intention where the failed plan is. In the general case, the
programmer will have included in that "\texttt{-!g}" plan another
attempt to achieve "\texttt{g}". When this happens, all relevant plans
will be checked again to find the set of \emph{currently} applicable
plans. Under the assumption that the contexts have been well defined
by the programmer, only plans that now stand a chance of succeeding
will be applicable. Differently from the above mechanism, here we have
the advantage of being better updated on the set of actually
applicable plans, but might be less efficient in that more checks need
to be done.

Another disadvantage of this approach is that to make sure a plan will
only be tried once (if in a particular application this is important,
although this is not always the case, surely), as it happens in other
platforms, the user will have to use, e.g., the belief base to keep
track of the previously attempted plans, or else to have the
applicable plan selection function checking the failed plans in the
stack of plans forming that intention (note that the failed plans are
still there and will only be removed, without executing further, when
the respective plan for "\texttt{-!g}" finishes) to decide which ones
not to use anymore (currently this might be tricky for most users to
do, although support for this is planned).

On the other hand, there is an extra advantage of the use of the
\jason plan failure handling mechanism. Pure "backtracking" as used in
logic programming might not always make sense in an agent program.
Recall that besides "sub-goals", plan bodies have \emph{actions}.
These actions, by definition, change something that is outside the
agent itself (the environment), so they cannot automatically be
"undone" by the interpreter in the process of backtracking. It is
therefore possible that none of the plans originally written (with a
particular set of initial situations in mind) to achieve the goal will
be applicable anymore. At least in some cases, it might be sensible to
let the "\texttt{-!g}" plan perform the necessary actions to bring the
environment back to a "reasonable" state in which the original plans
to achieve the goal can then be used again, rather than writing more
alternative plans for the original goal considering all possible
situations in which the agent can find itself when attempting to
achieve the goal.



\section{Developing Jason}

\subsection{How to build \jason from SourceForge SVN (subversion)?}

The SVN repository maintains the latest version of the \jason's
sources, so you will eventually need to build \jason from the SVN. To
do this the following softwares are required:
\begin{itemize}
\item a \htlink{SVN}{http://sourceforge.net/docs/B01} client program and
\item \htlink{Ant}{http://ant.apache.org/} version >= 1.6.2.
\end{itemize}

The steps to build are:
\begin{enumerate}
\item download the sources from SVN:
\begin{verbatim}
mkdir Jason-svn
cd Jason-svn
svn co https://jason.svn.sourceforge.net/svnroot/jason/trunk .
\end{verbatim}
%When prompted for a password for anonymous, simply press the Enter key.

\item create the \texttt{jason.jar} file and the jEdit plugin:
\begin{verbatim}
ant jar
ant plugin
\end{verbatim}

\textbb{Note}: if you are using Eclipse, set the output directory as
\texttt{bin/classes}.



\item create the API documentation:
\begin{verbatim}
ant apidoc
\end{verbatim}

More information is available at 
\htlink{SourceForge page}{http://sourceforge.net/svn/?group_id=98417}.

\end{enumerate}

\end{document}
