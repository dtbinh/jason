% To generate Jason 's FAQ.html

\documentclass{article}

\usepackage{tabularx}
\usepackage{html}
\usepackage{hthtml}
\usepackage{xspace}

\newcommand{\jason}[0]{\htlink{\textit{Jason}}{http://jason.sf.net}\xspace}
\newcommand{\saci}[0]{\htlink{\textsc{Saci}}{http://www.lti.pcs.usp.br/saci}\xspace}
\newcommand{\code}[1]{\texttt{#1}}

\begin{document}



\html{\begin{rawhtml}<h0><b><i>Jason</i></b> FAQ
      <br><font size="-1">(for version 0.9)</font></h0>
      \end{rawhtml}}
\latex{\begin{center}{\Huge\jason FAQ}\end{center}}

\tableofcontents


% ---------------------------------------------------------------------
\section{Platform Name}

\subsection{Does the name "Jason" have anything to do with a horror film?}
NO! \jason is a hero in Greek mythology. Click 
\begin{rawhtml}
  <a
  href="http://www.perseus.tufts.edu/cgi-bin/ptext?doc=Perseus%3Atext%3A1999.04.0004%3Ahead%3D%234815">here</a>
\end{rawhtml}
for an entry on "Jason" in the Perseus Encyclopaedia (Perseus is an
excellent source of Classics, maintained by Tufts University).


% ---------------------------------------------------------------------
\section{Internal Actions}

\subsection{How to create a new internal actions?}

The following steps will help you to define your internal action
(IA). The steps 1-4,6 are automatically done by Jason IDE, see menu
Plugin->Jason->New internal action".

\begin{enumerate}
\item In your MAS project directory, create a sub-directory called
  \code{myLib} (user's internal actions must be placed in a Java
  package, which provides a library of actions). In case this package
  directory is under your project directory, \jason automatically sets
  the classpath.

\item Copy an existing \jason internal action
  (\code{Jason/src/stdlib/concat.java}, for instance) to the
  \code{myLib} directory. This file will be used as a skeleton for
  your new IA.

\item Rename the file \code{myLib/concat.java} to
  \code{myLib/myIA.java}.

\item Edit this file and change the \code{package} name to
  \code{myLib}, and the class name to \code{myIA}.

  The code will likely look like
\begin{verbatim}
package myLib;

import jason.asSemantics.*;
import jason.asSyntax.*;

public class myIA extends DefaultInternalAction {
   public Object execute(TransitionSystem ts, 
                         Unifier un, 
                         Term[] args) 
                 throws Exception {
      ....
   }
}
\end{verbatim}

\item Code the \code{execute} method in order to implement the
  internal action.

\item Compile the new class
\begin{verbatim}
cd <your project directory>
javac -classpath ...../Jason/lib/jason.jar:. myLib/myIA.java
\end{verbatim}

\item Use the new IA in AgentSpeak sources, for example:
\begin{verbatim}
+a(X) : true
   <- ... ;
      myLib.myIA(A,B);
      ... .
\end{verbatim}


\end{enumerate}


\subsection{Is it possible to call an internal action from the
environment?}

Most of the internal actions (IAs) are developed from an agent
perspective, since they are conceived to be called by agents. Thus the
\code{execute} method needs an agent's
\code{TransitionSystem} (TS) to be executed (e.g. \code{.myName} make
sense only when called by an agent).

%However, some internal actions can be executed without a reference for
%a TS. For example, the IA \code{.killAgent} can
%be executed from the environment as shown in the code below:
%\begin{verbatim}
%import jason.stdlib.killAgent;
%...
%... in a centralised infrastructure ....
%...
%new killAgent().killCentralisedAg("bob", getEnvironmentInfraTier());
%...
%\end{verbatim}


% ---------------------------------------------------------------------
\section{MAS Execution}

\subsection{How to delay the MAS execution?}

If you have an environment class, the easiest way is simply add a
sleep in the \code{executeAction} method. For example:
\begin{verbatim}
    ...
    public boolean executeAction(String agent, Term action) {
        ...
        try { 
          Thread.sleep(500); 
        } catch (Exception e) {}
        ...
    }
\end{verbatim}

In case the agents do not act or there is no environment class, you
should write a controller class (see \ref{sec:controlclass}). 

For instance, the controller class could be:
\begin{verbatim}
package myPkg;
import ...
public class MyExecutionControl extends ExecutionControl {
    protected void allAgsFinished() {
        try { 
          Thread.sleep(500); 
        } catch (Exception e) {}
    }
}
\end{verbatim}

To use this controller, the project file must be
\begin{verbatim}
MAS test {
    ...
    executionControl: myPkg.MyExecutionControl

    agents:  ...
}
\end{verbatim}

\subsection{Is it possible to add/remove an agent into a running MAS?}

The internal action \code{.create_agent} can be used to dynamically
add a new agent into the running MAS. For example, when the plan:
\begin{verbatim}
+a : true 
   <- ... ; 
      .create_agent(bob, "myAgent.asl");
      ... .
\end{verbatim}
is executed, it will create a new agent called "bob" based on the
AgentSpeak code available at file "myAgent.asl".

Analogously, the internal action \code{.killAgent(<agent name>)}
removes the agent identified by \code{<agent name>} from the current
MAS. The createAgDemo project that comes with Jason distribution files
has examples of using these features.

New agents can also be created in the user Java code, for example:

\begin{verbatim}
public class myEnv extends Environment {
  ...
  public boolean executeAction(String ag, Term action) {
    ...
    getEnvironmentInfraTier().getRuntimeServices().
     .createAgent(
         "anotherAg",     // agent name
         "ag1.asl",       // AgentSpeak source
         null,            // default agent class
         null,            // default architecture class
         null,            // default belief base parameters
         null);           // default settings
  }
}
\end{verbatim}
The RuntimeServices interface, used in the code above, provides useful
services transparently from the underlying infrastructure
(Centralised, Saci, ...). The interface's methods include agent
creation, agent killing, and stop the system (see the API
documentation for more information).

Note that if you're using the \saci infrastructure, new
agents (possibly not \jason agents, see \ref{sec:whysaci}) can
enter the MAS using \saci features for open MAS.

\subsection{How to log the execution?}

\jason uses the \htlink{Java logging
  API}{http://java.sun.com/j2se/1.5.0/docs/guide/logging/overview.html}
% \htlink{Log4J}{http://logging.apache.org/log4j/}
to output messages into the console (the default console is called
MASConsole). To change the log level or device, select the menu
``Plugins -> Jason -> Edit Log properties''. The default configuration
file has comments that helps you to customise your log. For instance,
to output messages both into an XML file and in the console, you only
need to set the log handler as in the following line:
\begin{verbatim}
handlers = java.util.logging.FileHandler, java.util.logging.ConsoleHandler
\end{verbatim}
To get only console output (without MASConsole GUI):
\begin{verbatim}
handlers = java.util.logging.ConsoleHandler
\end{verbatim}


\subsection{Which execution modes are available?}

\jason is distributed with three execution modes:
\begin{itemize}
\item \textbf{Asynchronous}: all agents run asynchronously. An agent goes to
  its next reasoning cycle as soon as it has finished its current cycle.  This
  is the \textit{default} execution mode.
  
\item \textbf{Synchronous}: all agents perform one reasoning cycle at every
  "global execution step".  When an agent finished its reasoning cycle, it
  informs \jason's controller and waits for a "carry on" signal.  The \jason
  controller waits until all agents have finished their reasoning cycles and
  then sends the "carry on" signal to them.

To use this execution mode, you have to set up a controller class in
the .mas2j configuration, for example:
\begin{verbatim}
MAS test {
    infrastructure: Centralised
    environment: testEnv

    executionControl: jason.control.ExecutionControl

    agents:  ...
}
\end{verbatim}

The \code{jason.control.ExecutionControl} class implements exactly the "Jason
controller" described above.


\item \textbf{Debug}: this execution mode is similar to the synchronous mode,
  except that the \jason controller will also wait until the user clicks on a
  ``Step'' button before sending the ``carry on'' signal to the agents.
  
  To use this execution mode you can just press the ``debug'' button rather
  than the ``run'' button of the GUI, or you can to set up a debug controller
  class in the .mas2j configuration, for example:
\begin{verbatim}
MAS test {
    infrastructure: Centralised
    environment: testEnv

    executionControl: jason.control.ExecutionControlGUI

    agents:  ...
}
\end{verbatim}
  
  The \code{jason.control.ExecutionControlGUI} class implements the "Jason
  controller" with a GUI for debugging. This graphical tool is called
  "\jason's Mind Inspector", as it allows users to observe all changes in
  agents' mental attitudes after a reasoning cycle. This also applies to
  distributed agents (using \saci).

\end{itemize}



\subsection{How can I control agents' execution?}\label{sec:controlclass}

If you have other specific needs for controlling agents' execution, you have
to implement an \code{ExecutionControl} sub-class and specify it in the .mas2j
file.

You will most likely have to override the following methods:

\begin{verbatim}
public void receiveFinishedCycle(String agName, boolean breakpoint) {
   super.receiveFinishedCycle(agName, breakpoint);
   ... your code ...
}
protected void allAgsFinished() {
   ... your code ...
}
\end{verbatim}

These methods are called by \jason when one agent has finished its reasoning
cycle and when all agents have finished the current "global execution step".

To signal the agents to "carry on", your class can use the following code:
\begin{verbatim}
   fJasonControl.informAllAgsToPerformCycle();
\end{verbatim}

You should have a look at the \code{ExecutionControlGUI} class for an example
of how to do this, and the API documentation for further available methods
inherited from \code{ExecutionControl}.


% ---------------------------------------------------------------------
\section{\jason Infrastructures}


\subsection{What an infrastructure does?}

An infrastructure must provide the following services for the 
MAS:
\begin{itemize}
\item communication (e.g. \saci infrastructure implements it using
KQML),
\item control of the agent's life (creation, running, destruction).
\end{itemize}


\subsection{When should I use \saci infrastructure?}\label{sec:whysaci}

The centralised infrastructure does not support:
\begin{itemize}
\item execution of the agents at distributed hosts, and
\item interoperability with non-\jason agents.
\end{itemize}

If you need any of these features, you should choose the \saci infrastructure
(or implement a new infrastructure for \jason).

The interoperability with non-\jason agents is achieved by \saci through KQML
communication. An example of communication among \jason and \saci agents is
available at \htlink{Source
  Force}{https://sourceforge.net/project/showfiles.php?group_id=98417}.


\subsection{Is it possible to use only the \jason BDI engine?}

If you want to use only the \jason AgentSpeak interpreter and reasoning
features, you can implement your own agent class where the \jason available
infrastructure are not used.  This class must function as an "overall agent
architecture" for the AgentSpeak interpreter, i.e., it has to send
perceptions to the interpreter and get the agent actions (which result from
the AgentSpeak "reasoning").

Suppose you need a simple agent that interprets and reasons according to the
following AgentSpeak source:
\begin{verbatim}
+x(N) : N < 3  <- do(0).

+x(N) : N >= 3 <- do(50).
\end{verbatim}

The following class implements the required architecture (the
complete code is available with the examples in the \jason distribution). 
This code simply add \code{x(10)} into the agent's belief base through perception and get the output
action, in this case \code{do(50)}.

\begin{verbatim}
public class SimpleJasonAgent extends AgArch {
    public static void main(String[] a) {
       ...
       SimpleJasonAgent ag = new SimpleJasonAgent();
       ag.run();
    }


    public SimpleJasonAgent() {
         // set up the Jason agent and the 
         // TransitionSystem (the BDI Engine where the AS 
         // Semantics is implemented).

         Agent ag = new Agent();
         setTS(ag.initAg(this, 
                         new DefaultBeliefBase(), 
                         "demo.asl", // source code
                         new Settings()));
    }
    
    public void run() {
        while (true) {
          // calls the Jason engine to perform one reasoning cycle
          getTS().reasoningCycle();
        }
    }

    // this method just add some perception for the agent
    public List<Literal> perceive() {
        List<Literal> l = new ArrayList<Literal>();
        l.add(Literal.parseLiteral("x(10)"));
        return l;
    }

    // this method get the agent actions
    public void act(ActionExec action, List<ActionExec> feedback) {
        getTS().getLogger().info("Agent " + getAgName() + 
                             " is doing: " + action.getActionTerm());
        // set that the execution was ok
        action.setResult(true);
        feedback.add(action);
    }
}
\end{verbatim}

To run this agent:
\begin{verbatim}
export CLASSPATH= ../../lib/jason.jar:.
javac SimpleJasonAgent.java
java  SimpleJasonAgent
\end{verbatim}

The output will be 
\begin{verbatim}
[SimpleJasonAgent] Agent JasonAgent is doing: do(50)
\end{verbatim}

Of course, the AgentSpeak code in this example cannot use communication
actions since the specific architecture given above does not implement
communication.

\section{AgentSpeak Language}

Thanks to Mehdi Dastani for these questions.

\subsection{What exactly are the cases where negative events of the forms
  "-!p" and "-?p" are generated?}

A test goal "?p" in the body of a plan first checks the belief base,
and if it fails, it still tries to generate an internal event as that
might have been a more sophisticated query for which the programmer
created a whole plan with "+?p" as triggering event, then that could
be executed. Events "-!p" and "-?p" are only generated if an executing
plan for "+!g" and "+?g" (respectively) fail. Here's what the chapter
and the manual says about this:

\begin{quote}
  Events for handling plan failure are already available in Jason,
  although they are not formalised in the semantics yet. If an action
  fails or there is no applicable plan for a subgoal in the plan being
  executed to handle an internal event with a goal addition "+!g",
  then the whole failed plan is removed from the top of the intention
  and an internal event for "-!g" associated with that same intention
  is generated. If the programmer provided a plan that has a
  triggering event matching "-!g" and is applicable, such plan will be
  pushed on top of the intention, so the programmer can specify in the
  body of such plan how that particular failure is to be handled. If
  no such plan is available, the whole intention is discarded and a
  warning is printed out to the console. Effectively, this provides a
  means for programmers to "clean up" after a failed plan and before
  "backtracking" (that is, to make up for actions that had already
  been executed but left things in an inappropriate state for next
  attempts to achieve the goal). For example, for an agent that
  persist on a goal "!g" for as long as there are applicable plans for
  "+!g", suffices it to include a plan "-g! : true <- true." in the
  plan library. Note that the body can be empty as a goal is only
  removed from the body of a plan when the intended means chosen for
  that goal finishes successfully. It is also simple to specify a plan
  which, under specific condition, chooses to drop the intention
  altogether (by means of a standard internal action mentioned below).
\end{quote}

\subsection{Does "+p" (or "-p") in a plan body cause two effects,
  i.e. updating the belief base and generating the events "+p" (or "-p")?}

Yes, it causes both effects. Note, importantly, that one of the interpreter
configuration options allow the user to choose whether the event (\textbf{if}
it is by chance relevant to any plans the agent has) will be treated as
internal (pushed on top of the intention) or external (a new focus of
attention is created).

\subsection{Does "?p" in a plan body cause two effects, i.e. testing p
from the
  belief base and generating the events "+?p"? Is "-?p" generated when a
  test goal "?p" is failed? When does the test goal "?p" fails?}

When "?p" is executed, first the interpreter tries a simple query to the
belief base. If that doesn't succeed, before failing the intention, first an
internal event for "+?g" is generated, if that has no applicable plans, then
the plan fails (fails "normally", i.e., for the "no applicable plans"
reason) --- there could be still a "-?g" plan to be tried; if there's none,
the intention is discarded and a message printed to the console to let the
user know.

\subsection{It is claimed that open-world assumption is available. What
does this mean? Do we have a three-valued logic?}

No, we don't use three-valued logic. It means there is "strong negation", the
operator is "\url{~}". When assuming open world, the user models the
environment with a set of propositions known to be explicitly true and a set
of propositions known to be explicitly false of the environment at a certain
moment in time (the latter are literals preceeded by the \url{~} operator).
Of course, there is still default negation (as usual logic programming
languages), so you can say, in the context of a plan, "not p(t) \& not
\url{~}p(t)" to check if the agent is uncertain about "p(t)". Note that it's
completely up to the user to prevent paraconsistency (or to use it, if s/he
wants). You could add internal beliefs (or have beliefs from perception of the
environment) that p(t) is true and that ~p(t) is also true: \jason won't do
consistency checks for you! Note that strong negation can also appear in the
triggering events, plan body, anywhere a literal can appear.


\subsection{Why is \jason's plan failure mechanism different from
  other agent platforms?}

Some other platforms handle plan failure in the following way. When a
plan is selected as an intended means to achieve a goal (more
generally, to handle an event), other applicable plans might be
available or indeed other instantiations of the plan's variables (to
make the context a logical consequence of the belief base) might be
possible. Those platforms then make a "note" of all those plans and
plan instantiations. If the plan currently being executed fails,
another plan is chosen from that set of plans initially recorded as
alternative plans for handling that event. This has the great
advantage that the platform does not have to check for applicable
plans again, and has as disadvantage the fact that possibly the
agent's beliefs have changed and so plan considered applicable at the
time the first plan was selected, are actually no longer applicable
(yet they will be attempted, which increases the chance of the chosen
alternative plan failing as well).

In \jason, we opted for a different approach. When a plan with a
triggering event "\texttt{+!g}" fails, we generate an event
"\texttt{-!g}" and if the programmer provided a plan for that event
that is currently applicable, that plan is pushed on top of the
intention where the failed plan is. In the general case, the
programmer will have included in that "\texttt{-!g}" plan another
attempt to achieve "\texttt{g}". When this happens, all relevant plans
will be checked again to find the set of \emph{currently} applicable
plans. Under the assumption that the contexts have been well defined
by the programmer, only plans that now stand a chance of succeeding
will be applicable. Differently from the above mechanism, here we have
the advantage of being better updated on the set of actually
applicable plans, but might be less efficient in that more checks need
to be done.

Another disadvantage of this approach is that to make sure a plan will
only be tried once (if in a particular application this is important,
although this is not always the case, surely), as it happens in other
platforms, the user will have to use, e.g., the belief base to keep
track of the previously attempted plans, or else to have the
applicable plan selection function checking the failed plans in the
stack of plans forming that intention (note that the failed plans are
still there and will only be removed, without executing further, when
the respective plan for "\texttt{-!g}" finishes) to decide which ones
not to use anymore (currently this might be tricky for most users to
do, although support for this is planned).

On the other hand, there is an extra advantage of the use of the
\jason plan failure handling mechanism. Pure "backtracking" as used in
logic programming might not always make sense in an agent program.
Recall that besides "sub-goals", plan bodies have \emph{actions}.
These actions, by definition, change something that is outside the
agent itself (the environment), so they cannot automatically be
"undone" by the interpreter in the process of backtracking. It is
therefore possible that none of the plans originally written (with a
particular set of initial situations in mind) to achieve the goal will
be applicable anymore. At least in some cases, it might be sensible to
let the "\texttt{-!g}" plan perform the necessary actions to bring the
environment back to a "reasonable" state in which the original plans
to achieve the goal can then be used again, rather than writing more
alternative plans for the original goal considering all possible
situations in which the agent can find itself when attempting to
achieve the goal.



\section{Developing Jason}

\subsection{How to build \jason from SourceForge SVN (subversion)?}

The SVN repository maintains the latest version of the \jason's
sources, so you will eventually need to build \jason from the SVN. To
do this the following softwares are required:
\begin{itemize}
\item a \htlink{SVN}{http://sourceforge.net/docs/B01} client program and
\item \htlink{Ant}{http://ant.apache.org/} version >= 1.6.2.
\end{itemize}

The steps to build are:
\begin{enumerate}
\item download the sources from SVN:
\begin{verbatim}
mkdir Jason-svn
cd Jason-svn
svn co https://svn.sourceforge.net/svnroot/jason/trunk jason
\end{verbatim}
%When prompted for a password for anonymous, simply press the Enter key.

\item create the \texttt{jason.jar} file:
\begin{verbatim}
ant jar
\end{verbatim}

\item create the API documentation:
\begin{verbatim}
ant apidoc
\end{verbatim}

  More information is available at \htlink{SourceForge
    page}{http://sourceforge.net/svn/?group_id=98417}.

\end{enumerate}

\end{document}
